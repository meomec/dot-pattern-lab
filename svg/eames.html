<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="eames.css">
    <title>Charles Eames</title>
</head>
<body>
    <div class="controls">
        <label for="motif-selector">Choisir un motif :</label>
        <select id="motif-selector">
            <option value="all" selected>Tous les motifs</option>
            <option value="0">Motif 1</option>
            <option value="1">Motif 2</option>
            <option value="2">Motif 3</option>
            <option value="3">Motif 4</option>
            <option value="4">Motif 5</option>
            <option value="5">Motif 6</option>
        </select>
    </div>

    <div class="pattern">
        <div class="motif" id="motif-1" data-dimension-w="130.732" data-dimension-h="198.459" data-frequency="0.2">
            <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 130.7 198.5" style="enable-background:new 0 0 130.7 198.5;" xml:space="preserve">
                <g id="m1-assembly" class="assembly-collapse">
                    <g id="tree">
                        <path id="branch5" d="M66.4,129.4c.5,3.2,1.3,5.9,2.5,7.9,3.8,6.2,8,2.9,13.7,3.2,4.7.3,22.7,2.6,25.5.6.8-.6,1.3-1.5,1.7-2.4,0,0,.5,3.7.6,5.4s-1.4,3.5-1.4,3.5c-.7-1-1.4-1.8-2.4-2-4.7-.9-33.8.6-37.1,2.9-.9.7-1.7,2.7-2.3,5.3,0,0-1.9-5.5-1.9-12.2s1-12.2,1-12.2Z"/>
                        <path id="branch4" d="M61.1,151.8c-.3-2-.7-3.5-1.2-4-2.4-2.4-32.2-.9-38.2-2.3,0,0-.6-.7-1-2.3s.6-2.9.6-2.9c0,.1.1.2.2.3,1.3,1.6,21.2,1.2,24.9.9,4.1-.4,10.8-1.2,13.1-4.9.7-1.2,1.2-3.6,1.5-6.6,0,0,2.8,7.3,2.8,11.7s-2.7,10.2-2.7,10.2Z"/>
                        <path id="branch3" d="M65,39.8c0,1.1.1,1.9.2,2.2.6,3.8,3.9,6,7.5,6.5,1.5.2,14.2.9,15,.7.3,0,.6-.3.8-.7,0,0,.8.9.8,2.6s-.8,1.4-.8,1.4c-3.8-.6-16,.6-19,3-.6.5-3,1.5-3.3,2.3,0,0-1.6-1.2-2-7.4s.8-10.7.8-10.7Z"/>
                        <path id="branch2" d="M60.4,57c-.6-1.8-3.2-3.2-6.1-4.2-2-.7-12.5-2.1-13.2-1.3,0,0-.8-.2-.8-1.4s1.1-1.9,1.1-1.9c.1.2.2.3.3.3,2.4.6,16.5-1.3,17.8-3.1.3-.4.6-1.5.9-2.9,0,0,1.2,1.8,1.2,7.2s-1.2,7.2-1.2,7.2Z"/>
                        <path id="branch1" d="M66.7,57.2c-.8,7.7,1.7,19.2-.7,24.8,1.6,10.7.3,45.7.4,47.3s1.3,19.9.8,24.4-1.7,17.3-1.1,20.3c.1.7.5,1.3.9,1.9,0,0-1.2,1.9-2.4,1.9s-3.6-2-3.6-2c.6-.5.9-1.1,1.1-1.7.5-2.7-1-16.4-1-22.3s0-18.1,0-21.9,0-23.3,0-28.9c.1-11-.8-35.8-.8-50.3s0-6.1.2-8.1c.6-10.5,1.2-17.1.7-19.4,0,0-.6-2.2,1.2-1.7,3-1.5,3,.9,3,.9-.1,0-.2,0-.2.1-.6.6-.4,12-.1,17.2l1.7,17.4Z"/>
                    </g>
                    <path id="disc6" d="M67,175.9c2.7,3.1,9.5,4.5,8,14.1-2.2,14.1-30.9,9.9-21.8-7.8,1.6-3.2,5.8-4.5,7.8-6.4h6Z"/>
                    <path id="disc5" d="M109.8,138.7c1.1-2.6,2.1-5.7,9.7-5.1,15.3,1.1,15.4,24.5-2.8,20.8-4.7-1-6.2-4.5-7.8-6.8l.8-8.9Z"/>
                    <path id="disc4" d="M21.7,145.5c-2.4,13.5-22.3,9.1-21.7-3.4.4-8.9,11.3-13.2,18-8,2.7,2.1,2.3,4.6,3.3,6.2l.3,5.2Z"/>
                    <path id="disc3" d="M88.5,48.6c1.4-2.1,2.7-8.1,11-7,5.4.7,9.4,5.1,9.7,10.4.9,16.1-19,14.3-20.6.5v-3.9Z"/>
                    <path id="disc2" d="M41.1,51.6c-.7.7,1.6,6.6-5,9.5-18.3,8-23-23.5-3.6-20.4,6,1,8,6.2,8.9,7.6l-.3,3.3Z"/>
                </g>
                <path id="disc1" d="M61.1,23.2c-.2-.8-8.9-3.1-9.1-12.2-.5-19.1,30.6-11.4,20.6,7.6-2.5,4.7-6.2,3.6-7.3,3.9l-4.2.7Z"/>
            </svg>
        </div>

        <div class="motif" id="motif-2" data-dimension-w="136.575" data-dimension-h="136.378" data-frequency="0.1">
            <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 136.575 136.378" style="enable-background:new 0 0 136.575 136.378;" xml:space="preserve">
                <g id="m2-assembly" class="assembly-collapse">
                    <g id="tree">
                        <path id="branch2" d="M54.543,55.526c0.281,5.493,0.644,9.821,1.038,10.996c0.48,1.428,1.614,2.376,2.78,3.22l33.435,2.565
                            c5.567-0.979,14.894,1.186,19.871-0.002c0,0,0.663,0.06,0.663,1.342c0,1.283-0.663,1.579-0.663,1.579
                            c-15.129,1.385-33.085-1.719-47.853,0.017c-3.271,0.385-6.322,2.232-7.708,5.292c-1.097,2.423-1.805,9.88-2.074,17.015
                            c0,0-2.473-15.475-2.473-22.804S54.543,55.526,54.543,55.526z"/>
                        <path id="branch3" d="M21.031,69.511c0.103,0.689,0.214,1.249,0.486,1.573c1.396,1.664,24.942,0.364,26.831-1.308
                            c1.316-1.164,1.874-5.75,2.069-11.637c0,0,2.772,1.949,2.772,15.793S52.413,97.55,52.413,97.55
                            c-0.343-8.151-1.499-16.825-3.023-18.837c-0.771-1.017-1.942-1.448-3.06-1.94c-2.829-1.245-22.143-3.341-24.03-2.042
                            c0,0-1.196,0.342-2.01-1.613C19.475,71.164,21.031,69.511,21.031,69.511z"/>
                        <path id="branch1" d="M54.331,111.772c-0.438-2.297-0.528-8.143-0.299-14.222l0.51-42.025c-0.635-12.436-0.848-30.839-0.046-32.105
                            c0,0,0.439-0.873-2.145-0.873s-1.951,1.328-1.951,1.328c-0.38,2.58-0.233,8.794-0.077,15.855c0.135,6.102-0.228,12.066,0.093,18.409
                            c0.321,6.343,0.54,10.66,0.672,13.263s1.325,26.147,1.325,26.147c0.306,7.267-0.034,14.118-1.333,15.465c0,0,0.755,0.483,2.109,0
                            C54.543,112.532,54.331,111.772,54.331,111.772z"/>
                    </g>
                    <path id="disc2" d="M111.668,75.226c2.858,9.952,13.933,14.042,21.714,6.583c10.242-9.818-6.478-24.349-17.425-16.425
                        c-2.397,1.735-3.181,6.656-4.289,6.921L111.668,75.226z"/>
                    <path id="disc3" d="M22.3,74.731c-1.189,0.818-1.162,4.408-5.265,6.733c-20.004,11.334-24.99-26.792-0.747-18.649
                        c4.209,1.414,4.436,4.631,4.743,6.696L22.3,74.731z"/>
                    <path id="disc4" d="M54.497,23.421c0.167-0.263,3.866-1.316,5.405-3.095c4.9-5.665,2.057-17.898-5.305-19.81
                        c-16.767-4.357-18.838,20.244-4.195,23.36L54.497,23.421z"/>
                </g>
                <path id="disc1" d="M54.331,111.772c0.588,3.082,4.592,3.217,6.363,5.74c12.971,18.479-18.831,27.234-19.398,8.218
                    c-0.298-9.993,6.126-8.925,9.783-12.715L54.331,111.772z"/>
            </svg>
        </div>

        <div class="motif" id="motif-3" data-dimension-w="128.486" data-dimension-h="168.967" data-frequency="0.1">
            <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 128.486 168.967" style="enable-background:new 0 0 128.486 168.967;" xml:space="preserve">
                <g id="m3-assembly" class="assembly-collapse">
                    <g id="tree">
                        <path id="branch1" d="M65.985,146.135c0.042,0.175,0.196,0.318,0.434,0.451c0,0,1,0.278-2.176,0.278
                            c-3.177,0-2.167-0.739-2.167-0.739c-0.093-3.285,0.348-9.687,0.317-16.037c0,0-1.077-32.169-1.372-44.955
                            s-0.767-41.172-0.767-41.172c-0.062-5.419-0.267-10.859-0.269-15.716c0-1.619,1.08-3.977,0.881-4.866
                            c-0.063-0.28-0.264-0.53-0.571-0.768c0,0-0.288-0.911,1.504-1.196c1.792-0.285,1.78,0.401,1.78,0.401
                            c-0.315,0.202-0.527,0.416-0.583,0.647c-0.595,2.467-0.505,13.898-0.248,21.275c0,0,1.046,23.219,1.169,39.873s2,43.054,1.9,46.477
                            S65.581,144.454,65.985,146.135"/>
                        <path id="branch2" d="M42.764,63.339c0.083,0.718,0.135,1.235,0.309,1.41c0.661,0.664,15.658,1.909,16.498-4.424
                            c0.657-4.955,0.75-10.647,0.684-16.363c0,0,3.601,10.455,3.295,21.449c-0.305,10.994-2.444,17.669-2.433,16.877
                            c0.028-2.129-1.469-11.266-2.565-12.517c-1.241-1.417-12.814-2.519-14.86-1.813c-0.319,0.11-0.625,0.318-0.929,0.597
                            c0,0-0.894-0.945-0.894-2.228S42.764,63.339,42.764,63.339z"/>
                        <path id="branch4" d="M62.393,130.089c-0.035-7.195-0.676-14.324-3.386-16.773c-4.842-4.376-28.821-2.369-36.304-3.565
                            c0,0-0.637-0.867-0.637-2.14c0-1.273,0.881-2.185,0.881-2.185c0.929,0.758,2.326,1.279,4.626,1.38
                            c3.41,0.149,5.899-0.99,8.919-1.056c8.618-0.189,21.936,3.481,23.449-7.552c0.413-3.012,0.882-8.852,1.082-13.064
                            c0,0,1.197,4.33,1.726,22.883S62.393,130.089,62.393,130.089z"/>
                        <path id="branch5" d="M106.978,109.803c-9.44,2.962-35.388-4.427-40.017,7.415c-0.523,1.339-0.931,6.929-1.145,12.87
                            c0,0-1.382-12.837-1.961-21.316s0-23.639,0-23.639c0.017,7.307,0.895,14.855,2.271,17.063c4.268,6.851,21.914,3.571,28.402,3.507
                            c3.348-0.033,8.301,2.5,11.498,0.577c0,0,0.83-0.419,1.334,1.33C107.865,109.36,106.978,109.803,106.978,109.803z"/>
                        <path id="branch3" d="M84.608,68.717c-2.569-1.887-15.496-1.38-18.138,1.01c-1.864,1.687-3.209,9.419-3.193,16.388
                            c0,0-1.132-12.459-1.132-21.254s0-22.415,0-22.415c0.086,2.459,0.793,5.759,0.897,6.835c0.262,2.722,2.035,10.453,3.505,12.495
                            c3.43,4.762,12.893,4.705,17.811,3.042c0,0,0.691,0.347,0.691,1.813S84.608,68.717,84.608,68.717z"/>
                    </g>
                    <path id="disc2" d="M42.763,68.555c-2.271,2.077-4.507,8.106-12.134,7.211c-15.862-1.861-12.816-28.078,6.425-20.488
                        c4.931,1.945,5.46,5.908,5.71,8.061L42.763,68.555z"/>
                    <path id="disc4" d="M22.703,109.751c-2.79,7.115-8.855,13.062-16.625,8.492c-11.867-6.98-5.325-27.14,10.697-20.695
                        c4.618,1.857,3.599,5.778,6.171,7.878L22.703,109.751z"/>
                    <path id="disc5" d="M106.027,106.281c3.62-2.177,1.848-8.477,12.508-7.535c23.355,2.065-0.234,39.964-11.557,11.057
                        L106.027,106.281z"/>
                    <path id="disc3" d="M84.358,64.819c0.938-0.317,1.434-7.901,8.237-8.975c19.76-3.121,18.515,27.149-1.959,18.845
                        c-4.185-1.697-4.034-4.508-6.028-5.972L84.358,64.819z"/>
                    <path id="disc6" d="M66.419,146.586c1.672,0.931,7.522,1.36,8.519,8.792c2.526,18.826-19.304,15.403-20.842,5.857
                        c-1.248-7.745,0.971-12.064,7.98-15.109L66.419,146.586z"/>
                </g>
                <path id="disc1" d="M60.296,22.612c-2.149-1.666-9.457-2.785-10.29-10.306C49.218,5.208,51.981,1.522,59.004,0.19
                    c11.004-2.087,16.084,13.592,9.72,19.283c-1.013,0.906-3.89,1.537-5.145,2.344L60.296,22.612z"/>
            </svg>
        </div>

        <div class="motif" id="motif-4" data-dimension-w="112.557" data-dimension-h="131.027" data-frequency="0.08">
            <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 112.557 131.027" style="enable-background:new 0 0 112.557 131.027;" xml:space="preserve">
                <g id="m4-assembly" class="assembly-collapse">
                    <g id="tree">
                        <path id="branch3" d="M21.6,68.9c.3,1,.6,1.9,1.2,2.1,4,1,28.8-.6,30.9-4,0-7.6.9-15.6,1.5-23.5,0,0,2.1,19.4,2.1,28.3s-1.9,18.2-1.9,18.2c-.7-5.8-1.6-11-2.6-12.1-2.4-2.6-26.1-5-29.8-4,0,0-1.6-.2-1.7-1.6s.5-3.4.5-3.4Z"/>
                        <path id="branch1" d="M89.6,74.1c-6.3,1.8-23.6-.1-27.9,4.9-1.3,1.5-1.8,6.6-2,12.3,0,0-2-5-2-19.4s1.3-28.2,1.3-28.2c-.2,9.1-.2,19.4,2,22.9,1.7,2.7,8.5,3.8,11.9,4.1,2.3.2,15.3.5,16.2,0,.4-.3.7-.9,1-1.6,0,0,.8,1,.8,2.9s-1.3,2.1-1.3,2.1Z"/>
                        <path id="branch2" d="M59,43.8c.1-5.4.3-10.4.2-13.4,0-2.3-1.4-5-1.1-6.9.1-.9.8-1.5,1.6-2.1,0,0-1.4-1.5-3.4-1.5s-3.7.7-3.7.7c1.2,1.3,2.2,2.8,2.5,5,.7,5.8.5,11.8.1,17.9,0,0,.8,13.3.1,28.3-.7,15,0,18.3,0,18.3.9,8.2,1.3,17.7.4,19-.3.4-1,.7-1.8,1,0,0,1.2.7,2.9.7s2.3-1.2,2.3-1.2c.4-3.1.2-11,.5-18.1,0,0-1.3-7.8-1.4-19.4,0-7,.7-28.2.7-28.2Z"/>
                    </g>
                    <path id="disc4" d="M22.8,73.9c-.5.1-2.4,5.1-6.1,7.1-11.3,6.1-18.1-.5-16.5-12.5,1.4-10,15.7-9.7,20.4-2.5.4.7.7,1.9,1,2.9l1.2,5Z"/>
                    <path id="disc3" d="M59.1,109.4c12.1,2,14,21.3-.4,21.6-12.5.3-16.6-12.5-7-20.1.6-.4,1.4-.7,2.2-1l5.2-.6Z"/>
                    <path id="disc2" d="M90,69.2c1-2.6,2.2-7.4,9.8-8.2,21.5-2.3,12.6,28.8-3,20.8-2.6-1.4-6.3-7.5-7.2-7.7l.4-4.9Z"/>
                </g>
                <path id="disc1" d="M52.6,20.5c-2.8-3-7-4.6-6.5-11.1,1-12.8,19.9-12.8,20.5,1.4.3,7.3-4.3,8.8-6.9,10.5l-7.1-.8Z"/>
            </svg>
        </div>

        <div class="motif" id="motif-5" data-dimension-w="183.55" data-dimension-h="158.133" data-frequency="0.2">
            <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 183.55 158.133" style="enable-background:new 0 0 183.55 158.133;" xml:space="preserve">
                <g id="m5-assembly" class="assembly-collapse">
                    <g id="tree">
                        <path id="branch1" d="M160.4,56c-.3-.3-.7-.6-1.1-.9-5,.7-20.7-.5-32.8-.1l-36.3-.2c-22.2-1.2-44.4-.6-66.7-.8-.1.3-.2.6-.3.8,0,0-1.2.6-2.2-1.9s1-2.9,1-2.9c0,.3.6.6.5,1,13.2.4,25.7-1.4,38.9-1.1,7.9.2,18.1,2.2,25.9,2.1.6,0,1.6,0,2.9-.2l36.3-.7c8.2.2,16.7-.5,24.9-.2,2.7,0,5.4,1.4,8,1.2.5,0,.9-.4,1.4-.8,0,0,2,.9,2,2.5s-2.3,2.2-2.3,2.2Z"/>
                        <path id="branch2" d="M109.4,16.9c-.5,3.5-.7,7.1-.6,10.7,0,4.4.6,12.6,1.1,16.9.2,1.3.9,4.5,1.9,5.1.5.3,9.8,1.4,11.5,1.5,1.1,0,2.1.1,3.2.1,0,0-1.3,1.9-19.1,1.9s-17.2-1.3-17.2-1.3c4.1-.4,10.8-1.3,12-2,5.1-2.9,4.1-19.5,3.7-25.4-.3-3.2-.7-5.7-1.4-7.6,0,0-.8-3.4,2.2-3.4s2.7,3.4,2.7,3.4Z"/>
                        <path id="branch3" d="M149.1,10c-13,.8-27.1-2.2-39.1,3.2-.2,1.2-.4,2.4-.6,3.6,0,0-1,2.7-3.4-2.4s.7-6.5.7-6.5c16.8-.9,36.4-2.3,41.6-.9.9-.2,1.7-.6,2.4-1.2,0,0,1.6-.2.8,2.4s-2.3,1.8-2.3,1.8Z"/>
                        <path id="branch4" d="M80.9,7.9c1.8,1.2,13,.7,25.7,0,0,0,1.6.6,0,5.5s-2.2,3.4-2.2,3.4c-3.1-9-10.8-5.1-23-5.9,0,0-.8,0-1.4-1.2s.9-1.9.9-1.9Z"/>
                        <path id="branch5" d="M112,135.9c0-.5-.1-.9-.2-1.4-.9-8.8-1-25.6-.6-37.7l-1.4-27.7c-.5-4.2,0-8.9,1.3-10.9,1.5-2.3,7.8-3.2,15.4-3.4,0,0-8.9-4.7-18.2-4.7s-18.2,4.5-18.2,4.5c3.9.2,7.7.5,11.6.8,3.4,1,4.5,6.8,4.2,12.1l.7,29.1c.7,8.2,1,17.6,1.2,24.7.1,4.4.7,9.2.1,13.3-.2,1.2-.5,2.3-.9,3.3,0,0-2.5,4.4,2.6,3.7s2.6-4.3,2.6-4.3c-.1-.5-.2-1-.3-1.6Z"/>
                        <path id="branch6" d="M112.3,137.5c.4,1.5,1.2,2.8,2.8,3.7,3.3,1.9,15.1,3.5,19.2,3.8,5.3.4,19.4.9,24,0,.5,0,.9-.3,1.4-.7,0,0,1.2-1,1.2,1.9s-1.5,2.4-1.5,2.4c0-.2-.1-.5-.2-.7h-46.3s-3.5,0-3.5,0c0,0-1.3-3.5.4-7.8s2.6-2.7,2.6-2.7Z"/>
                        <path id="branch7" d="M82.9,143.3c.2.5.4.8.5.8,1.9.5,13.2.1,15.6-.3,4.4-.7,6.8-2.8,8-5.7,0,0,1.3-.3,2.2,2.8s1,7.1,1,7.1h-3.2s-21.7,0-21.7,0c-.4,0-.8.3-1.1.5,0,0-1.2,1.2-2.3-2.3s1-3,1-3Z"/>
                        <path id="branch8" d="M106.7,96.8c-.3-3-.6-5.8-.9-8.2-.7-4.7-5.2-6.9-9.5-7.5-2.6-.4-18.8.4-20.8,1.1-.3,0-.5.3-.7.5,0,0-2,2.7-2-2.6s1.9-3.2,1.9-3.2c.8.9,1.7,1.6,2.9,1.9,3.7.8,22.6-.1,25.5-1.8,1.5-.8,2.7-5,2.9-9.4,0,0,1.4,4.6,1.9,12.8s-1.1,16.3-1.1,16.3Z"/>
                        <path id="branch9" d="M123.8,80.5c-.5-3.9-1.6-2.8-1.6-2.8-.1.3-.3.5-.4.7-.2.3-.4.4-.6.5-.8.2-6.8-1.4-7.8-2-2-1.1-3.1-4.3-3.6-7.8,0,0-1.4,2.1-1,11.3s2.5,16.3,2.5,16.3c.1-3.2.3-6,.5-8.3.2-2.7.3-5.8,3.5-6.4,3.1-.6,5.2-.1,6.8.8.2.1.4.3.7.4,0,0,1.6,1.1,1.1-2.8Z"/>
                    </g>
                    <path id="disc8" d="M122.2,77.7c1.2-2.3,2.6-7.3,8.3-8.5,16.6-3.4,19.2,19.7,3.5,20.5-6.4.3-7.8-4.1-11.3-6.5l-.6-5.6Z"/>
                    <path id="disc7" d="M74.7,82.7c-1.6,1.7-2.6,6.6-8.5,7.3-15.9,1.9-15.7-21.5-1-20.7,6,.4,7.2,4.9,9.5,7.6v5.8Z"/>
                    <path id="disc6" d="M84.2,148.5c-2.3,1.7-3,7.1-10,7.4-14.9.7-15.9-22.4,0-20.9,5.8.6,7.8,6.1,8.7,8.2l1.3,5.3Z"/>
                    <path id="disc5" d="M159.7,144.3c1.7-1.4,3.1-4.4,6.1-5.8,12-5.5,21.2,10.4,10.3,17.3-8.1,5.2-14.2.8-16.8-7.2l.3-4.4Z"/>
                    <path id="disc4" d="M81.4,11c-.9.2-2.3,9-9.2,10-15.9,2.4-15.4-25,1.6-20.5,5.9,1.6,6.2,6.8,7.1,7.4l.5,3.1Z"/>
                    <path id="disc3" d="M150.6,5.8c2.1-1.8,4-4.7,9.6-4.8,15.8-.3,11.9,20.2.8,20.8-8.8.4-11-11.5-12-11.8l1.5-4.2Z"/>
                    <path id="disc2" d="M160.7,51.3c1.5-1.5,3.1-4.6,5.4-5.5,18.5-7.5,24.1,19.2,8.2,20.3-8,.6-9.5-6-13.9-10.1l.3-4.7Z"/>
                </g>
                <path id="disc1" d="M23.1,54.8c-5.9,14-28.2,9.6-22.1-7,4-10.9,20.9-8.8,20.8,2.3l1.3,4.7Z"/>
            </svg>
        </div>

        <div class="motif" id="motif-6" data-dimension-w="60.736" data-dimension-h="88.186" data-frequency="0.1">
            <svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 60.7 88.2">
                <g id="m6-assembly" class="assembly-collapse">
                    <g id="tree">
                        <path id="branch2" d="M51.7,45.9c0-1.5.2-11,0-16.5,0-1.6-1.5-7-1-7.5,0,0-.8-.6-1.9-.6-1.1,0-2.1.3-2.1.3.6.5,1.1.9,1.1,1,.2,1,.8,12,.7,13.5-.2,2.6-1,4.6-2.5,6.1-1.4,1.4-3.4,2.2-5.9,2.6-1.1.2-3.4.3-6,.3,0,0,1.5,1.1,3.7,1.5,3.9.7,9.7.8,10.8,1,3.5,0,3.2-.3,3.2-1.7Z"/>
                        <path id="branch3" d="M33.9,47.6c5.5.3,11,1,12.3,2.2,1.9,2,3,12.6,2.4,15.5-.1.6-.3,1-.6,1.5,0,0-1.1,1.4,2,.8,1.8-.3,1.6-1.4,1.6-1.4-.2-6.8,0-13.6.1-20.4,0,0-1-1.1-7.2-.3s-10.6,2-10.6,2Z"/>
                        <path id="branch1" d="M34,45.1c-4.4,0-9.7-.2-11.5-.9,0,0-1.1.1-.9,1.8.2,1.7,1.1,1.7,1.1,1.7,2-.3,6.5-.4,11.1-.1h1.2c0,0,17.2,1.2,16.6-.8s-16-1.7-16-1.7h-1.6Z"/>
                    </g>
                    <path id="disc3" d="M51.5,66.2c8.1,2.8,12.3,12.3,6.1,19.2-7.2,8-21.9-2.8-14.7-13.7,1.5-2.2,3.8-3.2,5-4.9,0,0,.5-.6,1.8-.7,1.4,0,1.8.1,1.8.1Z"/>
                    <path id="disc2" d="M46.5,21.6c-1.4-1.1-3.6-2.9-4.6-4.6-10.4-18.3,21-25.3,18.7-3.6-1,9.1-8.9,7.4-10,8.5,0,0-1,.4-2.3.3-1.2,0-1.8-.6-1.8-.6Z"/>
                </g>
                <path id="disc1" d="M22.8,47.8c-.2,0-.4,0-.5,0-1.5.4-1.7,7.9-8.2,9-22.8,3.6-14.9-31.2,3.1-20,3,1.9,3.6,5.8,5,7,.1,0,.3.2.4.3,0,0,.4.6.5,1.8,0,1.4-.2,1.7-.2,1.7Z"/>
            </svg>
        </div>
    </div>

    <script>
        const DEFAULT_CLONE_COUNT = 200;
        const DEFAULT_GRID_SCALE = 0.25;
        const selector = document.getElementById('motif-selector');
        const pattern = document.querySelector('.pattern');
        const motifTemplates = Array.from(document.querySelectorAll('.motif'));
        const frequencies = motifTemplates.map((motif) => parseFloat(motif.dataset.frequency) || 1);
        const cloneResetEntries = [];
        let resetSchedulerId = null;
        let resizeReflowTimerId = null;
        const colorFrequencies = {
            yellow: 0.1,
            red: 0.1,
            blue: 0.1,
            'light-green': 0.1,
            'dark-green': 0.1,
            pink: 0.1,
            black: 0.4,
        };
        const colorClasses = Object.keys(colorFrequencies);

        function parsePositiveInt(value, fallbackValue) {
            const parsed = parseInt(value || '', 10);
            if (!Number.isFinite(parsed) || parsed <= 0) return fallbackValue;
            return parsed;
        }

        function parseGridScale(value, fallbackValue) {
            const parsed = parseFloat(value || '');
            if (!Number.isFinite(parsed)) return fallbackValue;
            return Math.min(1.2, Math.max(0.05, parsed));
        }

        function parseBooleanQuery(value, fallbackValue = false) {
            if (value == null) return fallbackValue;
            const normalized = String(value).trim().toLowerCase();
            if (['1', 'true', 'yes', 'on'].includes(normalized)) return true;
            if (['0', 'false', 'no', 'off'].includes(normalized)) return false;
            return fallbackValue;
        }

        function parseColorMode(value) {
            const normalized = String(value || '').trim().toLowerCase();
            if (['black', 'noir'].includes(normalized)) return 'black';
            return 'color';
        }

        const queryParams = new URLSearchParams(window.location.search);
        const runtimeConfig = {
            cloneCount: parsePositiveInt(queryParams.get('n'), DEFAULT_CLONE_COUNT),
            gridScale: parseGridScale(queryParams.get('gridScale') || queryParams.get('scale'), DEFAULT_GRID_SCALE),
            colorMode: parseColorMode(queryParams.get('colorMode') || queryParams.get('color') || queryParams.get('couleur')),
            debugPlacement: parseBooleanQuery(queryParams.get('debug'), false),
        };

        function getActiveColorClasses() {
            if (runtimeConfig.colorMode === 'black') return ['black'];
            return colorClasses;
        }

        function getActiveColorWeight(colorClass) {
            if (runtimeConfig.colorMode === 'black') {
                return colorClass === 'black' ? 1 : 0;
            }
            return colorFrequencies[colorClass] || 0;
        }

        function clearCycleTimers() {
            cloneResetEntries.length = 0;
            if (resetSchedulerId !== null) {
                clearInterval(resetSchedulerId);
                resetSchedulerId = null;
            }
        }

        function ensureResetScheduler() {
            if (resetSchedulerId !== null) return;

            resetSchedulerId = window.setInterval(() => {
                if (cloneResetEntries.length === 0) {
                    clearInterval(resetSchedulerId);
                    resetSchedulerId = null;
                    return;
                }

                const now = Date.now();

                for (let i = cloneResetEntries.length - 1; i >= 0; i -= 1) {
                    const entry = cloneResetEntries[i];

                    if (!entry.clone.isConnected) {
                        cloneResetEntries.splice(i, 1);
                        continue;
                    }

                    if (now >= entry.nextResetAtMs) {
                        resetMotifCycleState(entry.clone, entry.motifIndex);
                        while (entry.nextResetAtMs <= now) {
                            entry.nextResetAtMs += entry.cycleMs;
                        }
                    }
                }
            }, 120);
        }

        function parseDurationToSeconds(value) {
            const input = (value || '').trim();
            if (!input) return NaN;

            if (input.endsWith('ms')) {
                return parseFloat(input) / 1000;
            }

            if (input.endsWith('s')) {
                return parseFloat(input);
            }

            return parseFloat(input);
        }

        function getCycleDurationSeconds() {
            const rootStyles = getComputedStyle(document.documentElement);
            const raw = rootStyles.getPropertyValue('--cycle-duration');
            const seconds = parseDurationToSeconds(raw);

            if (!Number.isFinite(seconds) || seconds <= 0) return 20;
            return seconds;
        }

        function getWeightedRandomIndex() {
            const totalFrequency = frequencies.reduce((sum, value) => sum + value, 0);
            let random = Math.random() * totalFrequency;
            for (let i = 0; i < frequencies.length; i++) {
                random -= frequencies[i];
                if (random <= 0) return i;
            }
            return frequencies.length - 1;
        }

        function getWeightedRandomIndexExcluding(excludedIndices = []) {
            const excluded = new Set(excludedIndices);
            const allowed = frequencies
                .map((frequency, index) => ({ index, frequency }))
                .filter((item) => !excluded.has(item.index) && item.frequency > 0);

            if (allowed.length === 0) {
                return getWeightedRandomIndex();
            }

            const totalFrequency = allowed.reduce((sum, item) => sum + item.frequency, 0);
            let random = Math.random() * totalFrequency;

            for (const item of allowed) {
                random -= item.frequency;
                if (random <= 0) return item.index;
            }

            return allowed[allowed.length - 1].index;
        }

        function getWeightedRandomColorClass() {
            const activeColorClasses = getActiveColorClasses();
            const totalFrequency = activeColorClasses.reduce((sum, colorClass) => {
                return sum + getActiveColorWeight(colorClass);
            }, 0);

            let random = Math.random() * totalFrequency;
            for (const colorClass of activeColorClasses) {
                random -= getActiveColorWeight(colorClass);
                if (random <= 0) return colorClass;
            }

            return activeColorClasses[0] || 'black';
        }

        function getWeightedRandomColorClassExcluding(excludedColorClasses = []) {
            const excluded = new Set(excludedColorClasses);
            const activeColorClasses = getActiveColorClasses();
            const allowed = activeColorClasses.filter((colorClass) => !excluded.has(colorClass) && getActiveColorWeight(colorClass) > 0);

            if (allowed.length === 0) {
                return getWeightedRandomColorClass();
            }

            const totalFrequency = allowed.reduce((sum, colorClass) => {
                return sum + getActiveColorWeight(colorClass);
            }, 0);

            let random = Math.random() * totalFrequency;
            for (const colorClass of allowed) {
                random -= getActiveColorWeight(colorClass);
                if (random <= 0) return colorClass;
            }

            return allowed[allowed.length - 1];
        }

        function applyCloneBaseStyle(clone, bloomDelay, colorClass) {
            const cycleDuration = getCycleDurationSeconds();
            const randomDelay = Math.random() * (cycleDuration * 0.15);
            const randomDuration = cycleDuration * (0.5 + Math.random() * 0.3);
            const randomMirrorX = Math.random() < 0.5;
            const randomMirrorY = Math.random() < 0.5;
            const allowMirroring = !clone.classList.contains('motif-type-2');
            const assignedColorClass = colorClass || getWeightedRandomColorClass();
            const width = parseFloat(clone.dataset.dimensionW);
            const height = parseFloat(clone.dataset.dimensionH);

            clone.style.setProperty('--bloom-delay', `${bloomDelay}s`);
            clone.style.setProperty('--animation-delay', `${randomDelay}s`);
            clone.style.setProperty('--float-duration', `${randomDuration}s`);
            clone.style.setProperty('--motif-left', '0px');
            clone.style.setProperty('--motif-top', '0px');
            clone.classList.toggle('mirror-x', allowMirroring && randomMirrorX);
            clone.classList.toggle('mirror-y', allowMirroring && randomMirrorY);
            clone.classList.add('color');
            clone.classList.remove(...colorClasses);
            clone.classList.add(assignedColorClass);
            clone.style.width = `${width * runtimeConfig.gridScale}px`;
            clone.style.height = `${height * runtimeConfig.gridScale}px`;

            if (runtimeConfig.debugPlacement) {
                clone.style.outline = '1px dashed rgba(0,0,0,0.35)';
                clone.style.outlineOffset = '2px';
            }
        }

        function getPatternViewport() {
            const bodyStyles = getComputedStyle(document.body);
            const bodyPaddingTop = parseFloat(bodyStyles.paddingTop) || 0;
            const bodyPaddingBottom = parseFloat(bodyStyles.paddingBottom) || 0;
            const viewportHeight = Math.max(520, window.innerHeight - bodyPaddingTop - bodyPaddingBottom);

            pattern.style.height = `${viewportHeight}px`;
            const width = Math.max(320, pattern.clientWidth || window.innerWidth);

            return { width, height: viewportHeight };
        }

        function getGridShape(targetCount, viewportWidth, viewportHeight) {
            const aspect = viewportWidth / Math.max(1, viewportHeight);
            const cols = Math.max(4, Math.round(Math.sqrt(targetCount * aspect)));
            const rows = Math.max(3, Math.ceil(targetCount / cols));
            return { cols, rows };
        }

        function buildWeightedQuotaMap(entries, totalCount) {
            const safeEntries = entries.map((entry) => ({
                key: entry.key,
                weight: Math.max(0, Number(entry.weight) || 0),
            }));

            const totalWeight = safeEntries.reduce((sum, entry) => sum + entry.weight, 0);
            const fallbackWeight = safeEntries.length > 0 ? 1 / safeEntries.length : 0;

            const raw = safeEntries.map((entry) => {
                const normalizedWeight = totalWeight > 0 ? entry.weight / totalWeight : fallbackWeight;
                const exact = normalizedWeight * totalCount;
                return {
                    key: entry.key,
                    count: Math.floor(exact),
                    remainder: exact - Math.floor(exact),
                };
            });

            let assigned = raw.reduce((sum, entry) => sum + entry.count, 0);
            let remaining = Math.max(0, totalCount - assigned);

            raw.sort((a, b) => b.remainder - a.remainder);
            let cursor = 0;
            while (remaining > 0 && raw.length > 0) {
                raw[cursor % raw.length].count += 1;
                cursor += 1;
                remaining -= 1;
            }

            const quota = new Map();
            raw.forEach((entry) => {
                quota.set(entry.key, entry.count);
            });

            return quota;
        }

        function pickKeyFromQuota(quotaMap, excludedKeys = []) {
            const excluded = new Set(excludedKeys);

            const allowed = [];
            const fallback = [];

            quotaMap.forEach((count, key) => {
                if (count <= 0) return;
                const target = excluded.has(key) ? fallback : allowed;
                target.push({ key, count });
            });

            const pool = allowed.length > 0 ? allowed : fallback;
            if (pool.length === 0) return null;

            const total = pool.reduce((sum, item) => sum + item.count, 0);
            let random = Math.random() * total;

            for (const item of pool) {
                random -= item.count;
                if (random <= 0) return item.key;
            }

            return pool[pool.length - 1].key;
        }

        function buildClonePlan(cellCount, cols) {
            const plan = [];
            const activeColorClasses = getActiveColorClasses();

            const motifQuota = buildWeightedQuotaMap(
                frequencies.map((weight, index) => ({ key: index, weight })),
                cellCount,
            );

            const colorQuota = buildWeightedQuotaMap(
                activeColorClasses.map((colorClass) => ({ key: colorClass, weight: getActiveColorWeight(colorClass) })),
                cellCount,
            );

            const enforceColorAdjacency = activeColorClasses.length > 1;

            for (let index = 0; index < cellCount; index += 1) {
                const col = index % cols;
                const row = Math.floor(index / cols);

                const leftIndex = col > 0 ? index - 1 : -1;
                const upIndex = row > 0 ? index - cols : -1;

                const excludedMotifs = [];
                const excludedColors = [];

                if (leftIndex >= 0) {
                    excludedMotifs.push(plan[leftIndex].motifIndex);
                    if (enforceColorAdjacency) excludedColors.push(plan[leftIndex].colorClass);
                }

                if (upIndex >= 0) {
                    excludedMotifs.push(plan[upIndex].motifIndex);
                    if (enforceColorAdjacency) excludedColors.push(plan[upIndex].colorClass);
                }

                const motifIndex = pickKeyFromQuota(motifQuota, excludedMotifs);
                const colorClass = pickKeyFromQuota(colorQuota, excludedColors);

                if (motifIndex !== null) {
                    motifQuota.set(motifIndex, Math.max(0, (motifQuota.get(motifIndex) || 0) - 1));
                }

                if (colorClass !== null) {
                    colorQuota.set(colorClass, Math.max(0, (colorQuota.get(colorClass) || 0) - 1));
                }

                plan.push({
                    motifIndex: motifIndex !== null ? motifIndex : getWeightedRandomIndex(),
                    colorClass: colorClass !== null ? colorClass : getWeightedRandomColorClass(),
                });
            }

            return plan;
        }

        function placeClonesInGrid(clones, cols, rows, viewportWidth, viewportHeight) {
            const cellWidth = viewportWidth / cols;
            const cellHeight = viewportHeight / rows;

            clones.forEach((clone, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const width = parseFloat(clone.style.width) || 80;
                const height = parseFloat(clone.style.height) || 80;

                const centerX = (col + 0.5) * cellWidth;
                const centerY = (row + 0.5) * cellHeight;
                const jitterX = (Math.random() - 0.5) * Math.min(24, cellWidth * 0.22);
                const jitterY = (Math.random() - 0.5) * Math.min(24, cellHeight * 0.22);

                const minX = width / 2;
                const maxX = Math.max(minX, viewportWidth - width / 2);
                const minY = height / 2;
                const maxY = Math.max(minY, viewportHeight - height / 2);

                const x = Math.max(minX, Math.min(maxX, centerX + jitterX));
                const y = Math.max(minY, Math.min(maxY, centerY + jitterY));

                clone.style.setProperty('--motif-left', `${x}px`);
                clone.style.setProperty('--motif-top', `${y}px`);
            });
        }

        function conflictsWithNearbyStyles(candidate, placed, adjacencyRadius) {
            for (let i = 0; i < placed.length; i += 1) {
                const other = placed[i];
                const dx = candidate.x - other.x;
                const dy = candidate.y - other.y;
                const distance = Math.hypot(dx, dy);

                if (distance > adjacencyRadius) continue;

                if (candidate.motifIndex === other.motifIndex) return true;
                if (candidate.colorClass === other.colorClass) return true;
            }
            return false;
        }

        function intersectsPlaced(candidate, placed, marginRatio) {
            for (let i = 0; i < placed.length; i += 1) {
                const other = placed[i];
                const dx = Math.abs(candidate.x - other.x);
                const dy = Math.abs(candidate.y - other.y);
                const minDxBase = (candidate.width + other.width) / 2;
                const minDyBase = (candidate.height + other.height) / 2;
                const minDx = minDxBase * (1 + marginRatio);
                const minDy = minDyBase * (1 + marginRatio);

                if (dx < minDx && dy < minDy) {
                    return true;
                }
            }
            return false;
        }

        function placeClonesPoissonConstrained(clones, viewportWidth, viewportHeight) {
            const placed = [];
            const marginRatios = [0.22, 0.16, 0.11, 0.07, 0.035, 0];
            const avgFootprint = clones.reduce((sum, clone) => {
                const width = parseFloat(clone.style.width) || 80;
                const height = parseFloat(clone.style.height) || 80;
                return sum + ((width + height) / 2);
            }, 0) / Math.max(1, clones.length);
            const adjacencyRadii = [2.2, 1.9, 1.65, 1.4, 1.15, 0.95].map((scale) => avgFootprint * scale);

            clones.forEach((clone) => {
                const width = parseFloat(clone.style.width) || 80;
                const height = parseFloat(clone.style.height) || 80;
                const motifIndex = parseInt(clone.dataset.motifIndex || '0', 10);
                const colorClass = clone.dataset.colorClass || '';

                const minX = width / 2;
                const maxX = Math.max(minX, viewportWidth - width / 2);
                const minY = height / 2;
                const maxY = Math.max(minY, viewportHeight - height / 2);

                let selectedPoint = null;

                for (let level = 0; level < marginRatios.length && !selectedPoint; level += 1) {
                    const marginRatio = marginRatios[level];
                    const adjacencyRadius = adjacencyRadii[level];

                    for (let attempt = 0; attempt < 260; attempt += 1) {
                        const x = minX + Math.random() * (maxX - minX || 1);
                        const y = minY + Math.random() * (maxY - minY || 1);
                        const candidate = { x, y, width, height, motifIndex, colorClass };

                        if (intersectsPlaced(candidate, placed, marginRatio)) continue;
                        if (conflictsWithNearbyStyles(candidate, placed, adjacencyRadius)) continue;

                        selectedPoint = candidate;
                        break;
                    }
                }

                if (!selectedPoint) {
                    selectedPoint = {
                        x: minX + Math.random() * (maxX - minX || 1),
                        y: minY + Math.random() * (maxY - minY || 1),
                        width,
                        height,
                        motifIndex,
                        colorClass,
                    };
                }

                placed.push(selectedPoint);
                clone.style.setProperty('--motif-left', `${selectedPoint.x}px`);
                clone.style.setProperty('--motif-top', `${selectedPoint.y}px`);

                if (runtimeConfig.debugPlacement) {
                    clone.title = `motif:${motifIndex + 1} | color:${colorClass} | x:${Math.round(selectedPoint.x)} y:${Math.round(selectedPoint.y)}`;
                }
            });
        }

        function getBalancedCloneCount(maxCount, viewportWidth, viewportHeight) {
            const sampleScale = runtimeConfig.gridScale;
            const avgArea = motifTemplates.reduce((sum, motif) => {
                const w = (parseFloat(motif.dataset.dimensionW) || 80) * sampleScale;
                const h = (parseFloat(motif.dataset.dimensionH) || 80) * sampleScale;
                return sum + (w * h);
            }, 0) / Math.max(1, motifTemplates.length);

            const availableArea = viewportWidth * viewportHeight;
            const densityFactor = 0.24;
            const targetCount = Math.floor((availableArea * densityFactor) / Math.max(1, avgArea));

            return Math.max(16, Math.min(maxCount, targetCount));
        }

        function applyMotif1Sequence(clone, bloomDelay) {
            const svg = clone.querySelector('svg');
            if (!svg) return;

            const cycleDuration = getCycleDurationSeconds();
            const asCycle = (ratio) => cycleDuration * ratio;

            const disc1 = svg.querySelector('#disc1');
            const branch1 = svg.querySelector('#branch1');
            const branch2 = svg.querySelector('#branch2');
            const branch3 = svg.querySelector('#branch3');
            const branch4 = svg.querySelector('#branch4');
            const branch5 = svg.querySelector('#branch5');
            const disc2 = svg.querySelector('#disc2');
            const disc3 = svg.querySelector('#disc3');
            const disc4 = svg.querySelector('#disc4');
            const disc5 = svg.querySelector('#disc5');
            const disc6 = svg.querySelector('#disc6');

            const growDuration = asCycle(0.035);
            const stepGap = asCycle(0.01);
            const disc1Delay = bloomDelay;
            const branch1Delay = disc1Delay + asCycle(0.0225);
            const branch23Delay = branch1Delay + growDuration;
            const disc23Branch45Delay = branch23Delay + growDuration + stepGap;
            const disc4Delay = disc23Branch45Delay + growDuration + asCycle(0.0075);
            const disc56Delay = disc4Delay + asCycle(0.0175);

            if (disc1) disc1.style.animationDelay = `${disc1Delay}s`;
            if (branch1) branch1.style.animationDelay = `${branch1Delay}s`;

            if (branch2) branch2.style.animationDelay = `${branch23Delay}s`;
            if (branch3) branch3.style.animationDelay = `${branch23Delay}s`;

            if (disc2) disc2.style.animationDelay = `${disc23Branch45Delay}s`;
            if (disc3) disc3.style.animationDelay = `${disc23Branch45Delay}s`;
            if (branch4) branch4.style.animationDelay = `${disc23Branch45Delay}s`;
            if (branch5) branch5.style.animationDelay = `${disc23Branch45Delay}s`;

            if (disc4) disc4.style.animationDelay = `${disc4Delay}s`;

            if (disc5) disc5.style.animationDelay = `${disc56Delay}s`;
            if (disc6) disc6.style.animationDelay = `${disc56Delay}s`;
        }

        function applyMotif2Sequence(clone, bloomDelay) {
            const svg = clone.querySelector('svg');
            if (!svg) return;

            const cycleDuration = getCycleDurationSeconds();
            const asCycle = (ratio) => cycleDuration * ratio;

            const disc1 = svg.querySelector('#disc1');
            const branch1 = svg.querySelector('#branch1');
            const branch2 = svg.querySelector('#branch2');
            const branch3 = svg.querySelector('#branch3');
            const disc2 = svg.querySelector('#disc2');
            const disc3 = svg.querySelector('#disc3');
            const disc4 = svg.querySelector('#disc4');

            const growDuration = asCycle(0.035);
            const stepGap = asCycle(0.01);
            const disc1Delay = bloomDelay;
            const branch1Delay = disc1Delay + asCycle(0.0225);
            const branch23Delay = branch1Delay + growDuration;
            const disc2Delay = branch23Delay + growDuration + stepGap;
            const disc3Delay = disc2Delay + asCycle(0.0125);
            const disc4Delay = disc3Delay + asCycle(0.0125);

            if (disc1) disc1.style.animationDelay = `${disc1Delay}s`;
            if (branch1) branch1.style.animationDelay = `${branch1Delay}s`;
            if (branch2) branch2.style.animationDelay = `${branch23Delay}s`;
            if (branch3) branch3.style.animationDelay = `${branch23Delay}s`;
            if (disc2) disc2.style.animationDelay = `${disc2Delay}s`;
            if (disc3) disc3.style.animationDelay = `${disc3Delay}s`;
            if (disc4) disc4.style.animationDelay = `${disc4Delay}s`;
        }

        function applyMotif3Sequence(clone, bloomDelay) {
            const svg = clone.querySelector('svg');
            if (!svg) return;

            const cycleDuration = getCycleDurationSeconds();
            const asCycle = (ratio) => cycleDuration * ratio;

            const disc1 = svg.querySelector('#disc1');
            const branch1 = svg.querySelector('#branch1');
            const branch2 = svg.querySelector('#branch2');
            const branch3 = svg.querySelector('#branch3');
            const branch4 = svg.querySelector('#branch4');
            const branch5 = svg.querySelector('#branch5');
            const disc2 = svg.querySelector('#disc2');
            const disc3 = svg.querySelector('#disc3');
            const disc4 = svg.querySelector('#disc4');
            const disc5 = svg.querySelector('#disc5');
            const disc6 = svg.querySelector('#disc6');

            const growDuration = asCycle(0.035);
            const stepGap = asCycle(0.01);
            const disc1Delay = bloomDelay;
            const branch1Delay = disc1Delay + asCycle(0.0225);
            const otherBranchesDelay = branch1Delay + growDuration;
            const disc2Delay = otherBranchesDelay + growDuration + stepGap;
            const disc3Delay = disc2Delay + asCycle(0.01);
            const disc4Delay = disc3Delay + asCycle(0.01);
            const disc5Delay = disc4Delay + asCycle(0.01);
            const disc6Delay = disc5Delay + asCycle(0.01);

            if (disc1) disc1.style.animationDelay = `${disc1Delay}s`;
            if (branch1) branch1.style.animationDelay = `${branch1Delay}s`;
            if (branch2) branch2.style.animationDelay = `${otherBranchesDelay}s`;
            if (branch3) branch3.style.animationDelay = `${otherBranchesDelay}s`;
            if (branch4) branch4.style.animationDelay = `${otherBranchesDelay}s`;
            if (branch5) branch5.style.animationDelay = `${otherBranchesDelay}s`;
            if (disc2) disc2.style.animationDelay = `${disc2Delay}s`;
            if (disc3) disc3.style.animationDelay = `${disc3Delay}s`;
            if (disc4) disc4.style.animationDelay = `${disc4Delay}s`;
            if (disc5) disc5.style.animationDelay = `${disc5Delay}s`;
            if (disc6) disc6.style.animationDelay = `${disc6Delay}s`;
        }

        function applyMotif4Sequence(clone, bloomDelay) {
            const svg = clone.querySelector('svg');
            if (!svg) return;

            const cycleDuration = getCycleDurationSeconds();
            const asCycle = (ratio) => cycleDuration * ratio;

            const disc1 = svg.querySelector('#disc1');
            const branch1 = svg.querySelector('#branch1');
            const branch2 = svg.querySelector('#branch2');
            const branch3 = svg.querySelector('#branch3');
            const disc2 = svg.querySelector('#disc2');
            const disc3 = svg.querySelector('#disc3');
            const disc4 = svg.querySelector('#disc4');

            const growDuration = asCycle(0.035);
            const stepGap = asCycle(0.01);
            const disc1Delay = bloomDelay;
            const branch2Delay = disc1Delay + asCycle(0.0225);
            const sideBranchesDelay = branch2Delay + growDuration;
            const sideDiscsDelay = sideBranchesDelay + growDuration + stepGap;
            const disc3Delay = sideDiscsDelay + asCycle(0.015);

            if (disc1) disc1.style.animationDelay = `${disc1Delay}s`;
            if (branch2) branch2.style.animationDelay = `${branch2Delay}s`;
            if (branch1) branch1.style.animationDelay = `${sideBranchesDelay}s`;
            if (branch3) branch3.style.animationDelay = `${sideBranchesDelay}s`;
            if (disc2) disc2.style.animationDelay = `${sideDiscsDelay}s`;
            if (disc4) disc4.style.animationDelay = `${sideDiscsDelay}s`;
            if (disc3) disc3.style.animationDelay = `${disc3Delay}s`;
        }

        function applyMotif5Sequence(clone, bloomDelay) {
            const svg = clone.querySelector('svg');
            if (!svg) return;

            const cycleDuration = getCycleDurationSeconds();
            const asCycle = (ratio) => cycleDuration * ratio;

            const branchGrowDuration = asCycle(0.03);
            const branchStartGap = branchGrowDuration;
            const discAfterBranchOffset = asCycle(0.006);
            const discStagger = asCycle(0.003);

            const disc1 = svg.querySelector('#disc1');
            if (disc1) {
                disc1.style.animationDelay = `${bloomDelay}s`;
            }

            const branchSequence = [
                { branch: 'branch1', discs: ['disc2'] },
                { branch: 'branch2', discs: [] },
                { branch: 'branch3', discs: ['disc3'] },
                { branch: 'branch4', discs: ['disc4'] },
                { branch: 'branch5', discs: [] },
                { branch: 'branch6', discs: ['disc5'] },
                { branch: 'branch7', discs: ['disc6'] },
                { branch: 'branch8', discs: ['disc7'] },
                { branch: 'branch9', discs: ['disc8'] },
            ];

            const firstBranchStart = bloomDelay + asCycle(0.02);

            branchSequence.forEach(({ branch, discs }, index) => {
                const branchStart = firstBranchStart + index * branchStartGap;
                const branchEl = svg.querySelector(`#${branch}`);
                if (branchEl) {
                    branchEl.style.animationDelay = `${branchStart}s`;
                }

                const firstDiscAt = branchStart + branchGrowDuration + discAfterBranchOffset;
                discs.forEach((discId, discIndex) => {
                    const discEl = svg.querySelector(`#${discId}`);
                    if (!discEl) return;
                    discEl.style.animationDelay = `${firstDiscAt + discIndex * discStagger}s`;
                });
            });
        }

        function applyMotif6Sequence(clone, bloomDelay) {
            const svg = clone.querySelector('svg');
            if (!svg) return;

            const cycleDuration = getCycleDurationSeconds();
            const asCycle = (ratio) => cycleDuration * ratio;

            const disc1 = svg.querySelector('#disc1');
            const branch1 = svg.querySelector('#branch1');
            const branch2 = svg.querySelector('#branch2');
            const branch3 = svg.querySelector('#branch3');
            const disc2 = svg.querySelector('#disc2');
            const disc3 = svg.querySelector('#disc3');

            const branchGrowDuration = asCycle(0.035);
            const branch3Offset = asCycle(0.01);
            const discsOffset = asCycle(0.0125);
            const disc3Offset = asCycle(0.0075);

            const branch1Delay = bloomDelay + asCycle(0.0225);
            const branch2Delay = branch1Delay + branchGrowDuration;
            const branch3Delay = branch2Delay + branch3Offset;
            const discsDelay = branch3Delay + branchGrowDuration + discsOffset;

            if (disc1) disc1.style.animationDelay = `${bloomDelay}s`;
            if (branch1) branch1.style.animationDelay = `${branch1Delay}s`;
            if (branch2) branch2.style.animationDelay = `${branch2Delay}s`;
            if (branch3) branch3.style.animationDelay = `${branch3Delay}s`;
            if (disc2) disc2.style.animationDelay = `${discsDelay}s`;
            if (disc3) disc3.style.animationDelay = `${discsDelay + disc3Offset}s`;
        }

        function resetMotifCycleState(clone, motifIndex) {
            if (!clone || !clone.isConnected) return;

            const selectorsByMotif = {
                0: ['#branch1', '#branch2', '#branch3', '#branch4', '#branch5', '#disc2', '#disc3', '#disc4', '#disc5', '#disc6'],
                1: ['#branch1', '#branch2', '#branch3', '#disc2', '#disc3', '#disc4'],
                2: ['#branch1', '#branch2', '#branch3', '#branch4', '#branch5', '#disc2', '#disc3', '#disc4', '#disc5', '#disc6'],
                3: ['#branch1', '#branch2', '#branch3', '#disc2', '#disc3', '#disc4'],
                4: ['#branch1', '#branch2', '#branch3', '#branch4', '#branch5', '#branch6', '#branch7', '#branch8', '#branch9', '#disc2', '#disc3', '#disc4', '#disc5', '#disc6', '#disc7', '#disc8'],
                5: ['#branch1', '#branch2', '#branch3', '#disc2', '#disc3'],
            };

            const selectors = selectorsByMotif[motifIndex] || [];
            const elements = selectors
                .map((selector) => clone.querySelector(selector))
                .filter(Boolean);

            if (elements.length === 0) return;

            elements.forEach((element) => {
                element.style.animation = 'none';
            });

            void clone.offsetWidth;

            elements.forEach((element) => {
                element.style.animation = '';
            });

            if (motifIndex === 0) {
                applyMotif1Sequence(clone, 0);
            }

            if (motifIndex === 1) {
                applyMotif2Sequence(clone, 0);
            }

            if (motifIndex === 2) {
                applyMotif3Sequence(clone, 0);
            }

            if (motifIndex === 3) {
                applyMotif4Sequence(clone, 0);
            }

            if (motifIndex === 4) {
                applyMotif5Sequence(clone, 0);
            }

            if (motifIndex === 5) {
                applyMotif6Sequence(clone, 0);
            }
        }

        function scheduleCloneCycleReset(clone, motifIndex, bloomDelay) {
            if (motifIndex !== 0 && motifIndex !== 1 && motifIndex !== 2 && motifIndex !== 3 && motifIndex !== 4 && motifIndex !== 5) return;

            const cycleDuration = getCycleDurationSeconds();
            const cycleMs = cycleDuration * 1000;
            const firstResetDelayMs = (bloomDelay + cycleDuration) * 1000;

            cloneResetEntries.push({
                clone,
                motifIndex,
                cycleMs,
                nextResetAtMs: Date.now() + firstResetDelayMs,
            });

            ensureResetScheduler();
        }

        function createClone(index, motifIndex, bloomDelay, colorClass) {
            const clone = motifTemplates[motifIndex].cloneNode(true);
            clone.id = `motif-clone-${index}`;
            clone.classList.add(`motif-type-${motifIndex + 1}`);
            if (motifIndex === 5) clone.classList.add('motif-type-6');
            clone.dataset.motifIndex = String(motifIndex);
            clone.dataset.colorClass = colorClass || '';

            applyCloneBaseStyle(clone, bloomDelay, colorClass);

            if (motifIndex === 0 || clone.classList.contains('motif-type-1')) {
                applyMotif1Sequence(clone, bloomDelay);
            }

            if (motifIndex === 1 || clone.classList.contains('motif-type-2')) {
                applyMotif2Sequence(clone, bloomDelay);
            }

            if (motifIndex === 2 || clone.classList.contains('motif-type-3')) {
                applyMotif3Sequence(clone, bloomDelay);
            }

            if (motifIndex === 3 || clone.classList.contains('motif-type-4')) {
                applyMotif4Sequence(clone, bloomDelay);
            }

            if (motifIndex === 4 || clone.classList.contains('motif-type-5')) {
                applyMotif5Sequence(clone, bloomDelay);
            }

            if (motifIndex === 5 || clone.classList.contains('motif-type-6')) {
                applyMotif6Sequence(clone, bloomDelay);
            }

            scheduleCloneCycleReset(clone, motifIndex, bloomDelay);

            return clone;
        }

        function generateRandomMotifs(count = runtimeConfig.cloneCount) {
            clearCycleTimers();
            pattern.innerHTML = '';
            const { width: viewportWidth, height: viewportHeight } = getPatternViewport();
            const targetCount = getBalancedCloneCount(count, viewportWidth, viewportHeight);
            const { cols, rows } = getGridShape(targetCount, viewportWidth, viewportHeight);
            const clonePlan = buildClonePlan(targetCount, cols);
            const clones = [];

            clonePlan.forEach((item, index) => {
                const bloomDelay = Math.random() * getCycleDurationSeconds();
                const clone = createClone(index, item.motifIndex, bloomDelay, item.colorClass);
                clones.push(clone);
            });

            placeClonesPoissonConstrained(clones, viewportWidth, viewportHeight);
            clones.forEach((clone) => pattern.appendChild(clone));
        }

        function showAllMotifs() {
            pattern.classList.remove('single-view');
            generateRandomMotifs(runtimeConfig.cloneCount);
        }

        function showSingleMotif(index) {
            clearCycleTimers();
            pattern.innerHTML = '';
            pattern.classList.add('single-view');

            const clone = motifTemplates[index].cloneNode(true);
            const width = parseFloat(clone.dataset.dimensionW);
            const height = parseFloat(clone.dataset.dimensionH);
            const singleScale = 2;
            const bloomDelay = 0;

            clone.classList.add(`motif-type-${index + 1}`);
            if (index === 5) clone.classList.add('motif-type-6');

            clone.style.setProperty('--bloom-delay', `${bloomDelay}s`);
            clone.style.setProperty('--animation-delay', '0s');
            clone.style.setProperty('--float-duration', '8s');
            clone.style.setProperty('--motif-left', '0px');
            clone.style.setProperty('--motif-top', '0px');

            if (index === 0) {
                applyMotif1Sequence(clone, bloomDelay);
            }

            if (index === 1) {
                applyMotif2Sequence(clone, bloomDelay);
            }

            if (index === 2) {
                applyMotif3Sequence(clone, bloomDelay);
            }

            if (index === 3) {
                applyMotif4Sequence(clone, bloomDelay);
            }

            if (index === 4) {
                applyMotif5Sequence(clone, bloomDelay);
            }

            if (index === 5) {
                applyMotif6Sequence(clone, bloomDelay);
            }

            scheduleCloneCycleReset(clone, index, bloomDelay);

            clone.id = 'motif-single';
            clone.style.width = `${width * singleScale}px`;
            clone.style.height = `${height * singleScale}px`;
            pattern.appendChild(clone);
        }

        selector.addEventListener('change', (event) => {
            const value = event.target.value;
            if (value === 'all') {
                showAllMotifs();
                return;
            }
            showSingleMotif(parseInt(value, 10));
        });

        window.addEventListener('DOMContentLoaded', () => {
            if (runtimeConfig.debugPlacement) {
                document.body.dataset.debugPlacement = 'true';
            }
            showAllMotifs();
        });

        window.addEventListener('resize', () => {
            if (resizeReflowTimerId !== null) {
                clearTimeout(resizeReflowTimerId);
            }

            resizeReflowTimerId = window.setTimeout(() => {
                resizeReflowTimerId = null;
                const value = selector.value;
                if (value === 'all') {
                    showAllMotifs();
                    return;
                }
                showSingleMotif(parseInt(value, 10));
            }, 180);
        });
    </script>
